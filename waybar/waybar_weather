#! /usr/bin/python3

import requests
import json
import time
import os
import socket
from dotenv import load_dotenv

load_dotenv()
API_KEY: str | None = os.getenv("API_KEY") # openweatherapi.org API
LAT: float = 50.6293 # Latitude
LON: float = 3.0573 # Longitude
UNITS: str = "metric" # standard | metric |imperial
COUNT: int = 1 # Get only n next hours
REQ_URL: str = f"https://api.openweathermap.org/data/2.5/forecast?lat={LAT}&lon={LON}&appid={API_KEY}&units={UNITS}&cnt={COUNT}"


def classify_entries(req: dict) -> dict:
    toreturn = {}
    for entry in req["list"]:
        toreturn[entry["dt"]] = entry
    
    return toreturn

def create_time_file(file: str) -> None:
    open(file, mode="x", encoding="utf-8")
    with open(file, mode="w", encoding="utf-8") as f:
        f.write("0")

def update_time(file: str) -> None:
    with open(file, mode="w", encoding="utf-8") as f:
        f.truncate(0)
        f.write(str(time.time()))

def get_last_update(file: str) -> float:
    with open(file, mode="r", encoding="utf-8") as f:
       return float(f.read())

def internet_available() -> bool:
    try:
        s = socket.create_connection(("1.1.1.1", 53))
        s.close()
        return True
    except Exception:
        return False
 
def main():
    # Create update file
    # FILE: str = "/home/karch/.config/waybar/weather_last_update"
    # if not os.path.exists(FILE):
    #     create_time_file(FILE)
    
    # Check for internet connection 
    if not internet_available():
        return json.dumps({"text": " No internet", "class": "weather"})

    # Check for last update 
    # last_update = get_last_update(FILE)
    # if (time.time() - last_update) < 300:
    #     print(time.time() - last_update)
    #     return
    # update_time(FILE)

    # Get request and entries
    req = requests.get(REQ_URL)
    if not req.ok:
        return json.dumps({"text": "API error!", "class": "weather"})
    
    content = json.loads(req.content)
    weather_report = classify_entries(req=content)
    
    # Use for multiple entries 
    # Advance 1 entry if next entry timestamp difference with current time is less than 15 minutes
    # current_time = int(time.time())
    # next_timestamp = weather_report[list(weather_report.keys())[1]]["dt"] 
    # if next_timestamp - current_time <= 900:
    #     weather_report.pop(0)
    
    # Generate text
    entry_keys = list(weather_report.keys())
    icons = {"Rain": "", "Clouds" : "", "Snow": "", "Clear": ""}
    weather_names = {"Rain": "Rainy", "Clouds": "Cloudy", "Snow": "Snowy", "Clear": "Clear"}
    text = ""
    for idx in range(COUNT):
        current_entry = weather_report[entry_keys[idx]]

        weather = current_entry["weather"][0]["main"]
        precipitation = int(current_entry["pop"] * 100)
        temp = int(current_entry["main"]["temp"])

        text += f"{icons[weather]} {weather_names[weather]} - {precipitation}% - {temp}ºC"
        # Use for multiple entries
        # text += f"{icons[weather]} {temp}ºC"
        # text += "  " if idx != 2 else ""
    
    return json.dumps({"text": text, "class": "weather"})
        

if __name__ == "__main__":
    weather = main()
    print(weather)


